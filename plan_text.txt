fastapi_htmx_paint/
├── app/
│   ├── main.py
│   ├── core.py
│   ├── models/
│   │   ├── predictor.py
│   │   └── train_model.py
│   ├── routes/
│   │   └── home.py
│   ├── templates/
│   │   ├── base.html
│   │   ├── index.html
│   │   └── partial_result.html
│   └── static/
│       ├── style.css
│       └── app.js
├── model/
│   └── mnist_lr.joblib      # (train qilingandan keyin paydo bo‘ladi)
├── Dockerfile
├── requirements.txt
└── README.md
fastapi
uvicorn[standard]
jinja2
scikit-learn
joblib
numpy
Pillow
python-multipart
htmx.org




htmx.org paketini PyPI orqali ham qo‘shdik (frontendda CDN ham ishlaydi). Agar htmx.org PyPI sizning muhitda kerak bo‘lmasa, frontendda CDN ishlatish yetarli.

2) app/core.py
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATES_DIR = BASE_DIR / "app" / "templates"
STATIC_DIR = BASE_DIR / "app" / "static"
MODEL_DIR = BASE_DIR / "model"
MODEL_PATH = MODEL_DIR / "mnist_lr.joblib"

3) app/models/train_model.py — (bir marta localda ishlatib model yarating)
"""
Oddiy script: MNISTni yuklab, sklearn LogisticRegression bilan o'qitib
modelni `model/mnist_lr.joblib` ga saqlaydi.
Iltimos: bu scriptni lokal mashinada yoki kuchli CI muhitda ishga tushiring.
"""

import os
from pathlib import Path
import joblib
import numpy as np
from sklearn.datasets import fetch_openml
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

HERE = Path(__file__).resolve().parent.parent.parent
MODEL_DIR = HERE / "model"
MODEL_DIR.mkdir(parents=True, exist_ok=True)
MODEL_PATH = MODEL_DIR / "mnist_lr.joblib"

def main():
    print("MNIST yuklanmoqda... (bir necha daqiqa)")
    X, y = fetch_openml("mnist_784", version=1, as_frame=False, cache=True)
    X = X / 255.0
    y = y.astype(int)

    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42
    )

    print("Modelni o'qitish (LogisticRegression)...")
    clf = LogisticRegression(solver="saga", max_iter=200, n_jobs=-1, verbose=1)
    clf.fit(X_train, y_train)

    y_pred = clf.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    print(f"Test accuracy: {acc:.4f}")

    print(f"Model saqlanmoqda: {MODEL_PATH}")
    joblib.dump(clf, MODEL_PATH)
    print("Tugatildi.")

if __name__ == "__main__":
    main()


Ishga tushirish (lokalda):

pip install -r requirements.txt
python app/models/train_model.py


Bu model/mnist_lr.joblibni hosil qiladi. (Agar siz doimiy serverga deploy qilayotgan bo‘lsangiz, modelni lokalda train qilib compga saqlab, repo-ga yoki storage-ga joylang.)

4) app/models/predictor.py
import base64
import io
from pathlib import Path
from PIL import Image
import numpy as np
import joblib

from app.core import MODEL_PATH

class Predictor:
    def __init__(self):
        self.model = None
        self._load_model()

    def _load_model(self):
        if MODEL_PATH.exists():
            self.model = joblib.load(MODEL_PATH)
        else:
            # Model topilmasa, None qoldiramiz.
            # Siz deploy qilishdan oldin modelni train qilib joylang.
            raise FileNotFoundError(f"Model topilmadi: {MODEL_PATH}")

    def preprocess_base64(self, data_url: str):
        """
        data_url: "data:image/png;base64,...."
        """
        if "," in data_url:
            header, b64 = data_url.split(",", 1)
        else:
            b64 = data_url
        image_data = base64.b64decode(b64)
        img = Image.open(io.BytesIO(image_data)).convert("L")
        # 28x28 ga o'zgartirish. Biz canvas 280x280 ishlatamiz.
        img = img.resize((28, 28), Image.LANCZOS)
        arr = np.array(img, dtype=np.float32)
        # Invert: canvasda qora belgi bo'lsa (0) va fon oq bo'lsa (255) — MNIST bo'yicha
        arr = 255.0 - arr
        arr = arr / 255.0
        arr_flat = arr.reshape(1, -1)
        return arr_flat

    def predict_from_base64(self, data_url: str) -> int:
        x = self.preprocess_base64(data_url)
        pred = self.model.predict(x)
        return int(pred[0])

5) app/routes/home.py
from fastapi import APIRouter, Request, Form
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from starlette.concurrency import run_in_threadpool
from app.core import TEMPLATES_DIR
from app.models.predictor import Predictor

router = APIRouter()
templates = Jinja2Templates(directory=str(TEMPLATES_DIR))

# predictor global obyekt (yuklash bitta marta)
predictor = Predictor()

@router.get("/", response_class=HTMLResponse)
async def index(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@router.post("/predict", response_class=HTMLResponse)
async def predict(request: Request, image: str = Form(...)):
    """
    HTMX orqali keladigan form: hidden input name="image" ichida dataURL (base64) bo'ladi.
    Biz predict operatsiyasini threadpoolda bajarib, partial template qaytaramiz.
    """
    # CPU-bound predictni threadpoolda bajarish
    pred = await run_in_threadpool(predictor.predict_from_base64, image)
    return templates.TemplateResponse("partial_result.html", {"request": request, "result": pred})

6) app/main.py
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from app.routes import home
from app.core import STATIC_DIR

app = FastAPI(title="Paint Digit Recognizer - FastAPI + HTMX + sklearn")

app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")
app.include_router(home.router)

7) Templates
app/templates/base.html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Paint Digit Recognizer</title>
  <link rel="stylesheet" href="/static/style.css" />
  <script src="https://unpkg.com/htmx.org@1.9.3"></script>
</head>
<body>
  <div class="container">
    <header>
      <h1>Paint Digit Recognizer</h1>
    </header>
    <main>
      {% block content %}{% endblock %}
    </main>
    <footer>
      <p>FastAPI + HTMX + sklearn demo</p>
    </footer>
  </div>
  <script src="/static/app.js"></script>
</body>
</html>

app/templates/index.html
{% extends "base.html" %}
{% block content %}
<div class="panel">
  <p>Canvas-ga raqam chizing (mobil / desktop bilan):</p>

  <canvas id="paint" width="280" height="280"></canvas>

  <div class="controls">
    <button id="clearBtn" type="button">Tozalash</button>

    <!-- Bu form HTMX bilan yuboriladi. JS canvas toDataURL qilib hidden inputga joylaydi -->
    <form id="predictForm" hx-post="/predict" hx-target="#result" hx-swap="innerHTML">
      <input type="hidden" name="image" id="imageInput" />
      <button id="predictBtn" type="submit">Predict</button>
    </form>
  </div>

  <div id="result">
    <!-- Natija shu yerga keladi (partial_result.html) -->
  </div>
</div>
{% endblock %}

app/templates/partial_result.html
<!-- HTMX orqali qaytadi va #result ichini yangilaydi -->
<div class="result">
  <p>Taxmin qilingan raqam: <strong>{{ result }}</strong></p>
</div>

8) Static fayllar
app/static/style.css
body {
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: #f7f7fb;
  color: #111;
  margin: 0;
  padding: 20px;
}
.container { max-width: 720px; margin: 0 auto; }
header h1 { margin: 0 0 16px; }
.panel { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 6px 18px rgba(0,0,0,0.06); }
canvas { border: 2px solid #222; display: block; margin: 8px 0; background: white; touch-action: none; }
.controls { display: flex; gap: 8px; align-items: center; margin-top: 8px; }
button { padding: 8px 14px; border-radius: 6px; border: none; background: #2563eb; color: #fff; cursor: pointer; }
button#clearBtn { background: #ef4444; }
.result { margin-top: 14px; font-size: 20px; }

app/static/app.js
// Canvas paint + hidden inputni to'ldirish + smoot drawing
(function () {
  const canvas = document.getElementById("paint");
  const ctx = canvas.getContext("2d");
  const imageInput = document.getElementById("imageInput");
  const clearBtn = document.getElementById("clearBtn");
  const predictForm = document.getElementById("predictForm");

  // init
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.lineWidth = 20;
  ctx.lineCap = "round";
  ctx.strokeStyle = "black";

  let drawing = false;
  let last = { x: 0, y: 0 };

  function getPos(e) {
    if (e.touches) {
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      return { x: t.clientX - rect.left, y: t.clientY - rect.top };
    }
    return { x: e.offsetX, y: e.offsetY };
  }

  function start(e) {
    drawing = true;
    last = getPos(e);
  }
  function stop() {
    drawing = false;
    ctx.beginPath();
  }
  function move(e) {
    if (!drawing) return;
    e.preventDefault();
    const pos = getPos(e);
    ctx.beginPath();
    ctx.moveTo(last.x, last.y);
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
    last = pos;
  }

  canvas.addEventListener("mousedown", start);
  canvas.addEventListener("mouseup", stop);
  canvas.addEventListener("mouseout", stop);
  canvas.addEventListener("mousemove", move);

  canvas.addEventListener("touchstart", start, { passive: false });
  canvas.addEventListener("touchend", stop);
  canvas.addEventListener("touchcancel", stop);
  canvas.addEventListener("touchmove", move, { passive: false });

  clearBtn.addEventListener("click", function () {
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    // Clear result
    const resultDiv = document.getElementById("result");
    if (resultDiv) resultDiv.innerHTML = "";
  });

  // Before HTMX submits the form, put canvas dataURL into hidden input
  predictForm.addEventListener("submit", function (ev) {
    // toDataURL default png
    const dataURL = canvas.toDataURL("image/png");
    imageInput.value = dataURL;
    // allow HTMX to submit
  });
})();

9) Dockerfile
# Python 3.11 image (yoki 3.10)
FROM python:3.11-slim

WORKDIR /app

# system deps for pillow
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libjpeg-dev \
    zlib1g-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r /app/requirements.txt

# App files
COPY . /app

# create model dir if not exists
RUN mkdir -p /app/model

#  If you want to include pre-trained model into image, copy it here.
#  Otherwise, mount model directory or run train script before docker build.

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--proxy-headers", "--limit-concurrency", "10"]


Eslatma: agar Docker image ichiga modelni joylashtirmoqchi bo‘lsangiz, model/mnist_lr.joblib faylini COPY orqali qo‘shing yoki build vaqtida train qilishni qilmang (train vaqt oladi). Lokalda train qilib modelni model/ papkaga qo‘ying, keyin docker build qiling.

10) README.md (qisqacha, to‘liq ko‘rsatma)
# FastAPI + HTMX + Canvas Digit Recognizer (sklearn)

Bu loyiha FastAPI + HTMX yordamida web-sahifada **paint-style** canvasga chizilgan raqamni (0-9) tanib beradi. Model sklearn (LogisticRegression) bilan MNISTda o'qitiladi.

## Strukturasi


fastapi_htmx_paint/
├── app/...
├── model/mnist_lr.joblib
├── Dockerfile
├── requirements.txt
└── README.md


## Talablar
- Python 3.10+
- pip

## O'rnatish (lokal)

1. Repo klonlang:
```bash
git clone <repo>
cd fastapi_htmx_paint


Virtual muhit yarating va paketlarni o‘rnating:

python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt


Modelni yaratish (bir marta bajariladi — bu bir necha daqiqa oladi):

python app/models/train_model.py


Bu model/mnist_lr.joblib faylini hosil qiladi.

Serverni ishga tushiring:

uvicorn app.main:app --reload


Brauzerda oching: http://127.0.0.1:8000

Docker bilan

Modelni oldin model/mnist_lr.joblib yaratib, loyihaning model/ papkasiga joylang:

# localda train qilib model/mnist_lr.joblib qiling
docker build -t paint-digit .
docker run -p 8000:8000 -v $(pwd)/model:/app/model paint-digit


Yoki model image ichiga COPY qiling (agar xohlasangiz).

Qanday ishlaydi

Foydalanuvchi canvasga raqam chizadi.

"Predict" tugmasi bosiladi.

JS canvasni base64 qilib formga joylaydi.

HTMX formni /predict ga yuboradi.

Server predictor model orqali raqamni taxmin qiladi va partial template qaytaradi.

HTMX natijani sahifada faqat #result div ichida yangilaydi.

Performance eslatma

Bu loyiha sklearn (LogisticRegression) ishlatadi — resurs jihatdan yengilroq. Lekin eskirgan skanlar yoki juda chalkash chizmalar uchun aniqlik CNN (PyTorch/TensorFlow)ga qaraganda past bo‘lishi mumkin.

Deployda 512MB RAM bilan ham ishlaydi (oddiy inferensiyalar uchun), ammo model o‘lchami va trafikni hisobga oling.
